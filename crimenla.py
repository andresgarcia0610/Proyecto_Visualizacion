# -*- coding: utf-8 -*-
"""crimenLA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eQ3UP9jo94RoUG4TAjOR0bkiTnO0I6Gs
"""

import pandas as pd

# Ruta al archivo en Google Drive


# Leer el archivo CSV
df = pd.read_csv(r"C:\Users\andre\Desktop\Proyecto Visualización\crimen23.csv")

# Mostrar las primeras filas del DataFrame
df.head()

import pandas as pd
import plotly.express as px


# Asegúrate de que las columnas LAT y LON estén en el formato correcto
df['LAT'] = pd.to_numeric(df['LAT'], errors='coerce')
df['LON'] = pd.to_numeric(df['LON'], errors='coerce')

# Filtrar los datos con latitudes y longitudes válidas
df_valid = df.dropna(subset=['LAT', 'LON'])

# Contar el número de crímenes por zona (por cada latitud y longitud)
df_crime_counts = df_valid.groupby(['LAT', 'LON']).size().reset_index(name='Crimenes Totales')

# Crear el mapa de calor con la cuenta de crímenes
fig = px.density_mapbox(df_crime_counts, lat='LAT', lon='LON', z='Crimenes Totales',
                        hover_name='Crimenes Totales', color_continuous_scale="Viridis",
                        title="Mapa de Calor de Crímenes en Los Ángeles",
                        mapbox_style="open-street-map", opacity=0.5,  # Aquí ajustamos la opacidad
                        zoom=10,  # Ajusta el nivel de zoom (mayor número = más cerca)
                        center={'lat': 34.0522, 'lon': -118.2437}  # Centrado en Los Ángeles
                        )

# Mostrar el mapa de calor
fig.show()

# Importar las librerías necesarias
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Asegúrate de cargar tu dataset en el DataFrame 'df'. Por ejemplo:
# df = pd.read_csv('ruta_al_archivo.csv')

# Convertir las variables categóricas en numéricas
df['Vict Sex_num'] = df['Vict Sex'].map({'M': 1, 'F': 0, 'U': 2})  # Mapear 'Vict Sex' a números
df['Vict Descent_num'] = df['Vict Descent'].map({
    'W': 0, 'H': 1, 'B': 2, 'A': 3, 'O': 4, 'U': 5, 'N': 6, 'L': 7, 'P': 8, 'S': 9
})  # Mapear 'Vict Descent' a números

# Contar el total de crímenes por cada 'Vict Age'
total_crimenes = df.groupby('Vict Age').size().reset_index(name='Total Crimes')

# Unir el DataFrame original con el total de crímenes por 'Vict Age'
df = pd.merge(df, total_crimenes, on='Vict Age', how='left')

# Seleccionar las variables de interés para la correlación
df_corr = df[['Vict Age', 'Total Crimes', 'Vict Sex_num', 'Vict Descent_num']].dropna()  # Variables relevantes

# Calcular la matriz de correlación
corr_matrix = df_corr.corr()  # Matriz de correlación

# Crear el mapa de calor
plt.figure(figsize=(8, 6))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)

# Título y mostrar el gráfico
plt.title('Matriz de Correlación de Variables')
plt.show()

# Importar las librerías necesarias
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Filtrar las filas de acuerdo con las letras 'W', 'B', 'H', 'A' en 'Vict Descent'
df_filtered = df[df['Vict Descent'].isin(['W', 'B', 'H', 'A'])]

# Asegurarse de que 'fecha' esté en formato de fecha
df_filtered['fecha'] = pd.to_datetime(df_filtered['fecha'])

# Crear una nueva columna para el mes (usando la columna 'fecha')
df_filtered['Month'] = df_filtered['fecha'].dt.month

# Contar el número de crímenes por mes y por 'Vict Descent'
crime_counts = df_filtered.groupby(['Month', 'Vict Descent']).size().reset_index(name='Crime Count')

# Crear el gráfico de líneas
plt.figure(figsize=(12, 6))

sns.lineplot(data=crime_counts,
             x='Month',
             y='Crime Count',
             hue='Vict Descent',
             palette='Set1',  # Colores para cada categoría
             marker='o',  # Marcar cada punto con un círculo
             linewidth=2)  # Ancho de las líneas

# Personalizar el gráfico
plt.title('Número Total de Crímenes por Mes y Raza de la Víctima', fontsize=16)
plt.xlabel('Mes', fontsize=12)
plt.ylabel('Número de Crímenes', fontsize=12)

# Ajustar las etiquetas del eje x para que se vean centradas
plt.xticks(ticks=range(1, 13), labels=['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'], rotation=0)

# Mejorar la disposición del gráfico
plt.tight_layout()

# Mostrar el gráfico
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# Filtrar el DataFrame para solo incluir los valores deseados de 'Vict Descent' y 'Vict Sex'
df_filtered = df[df['Vict Descent'].isin(['W', 'B', 'H', 'A']) & df['Vict Sex'].isin(['M', 'F'])]

# Crear una figura con 2 filas y 2 columnas de subgráficos
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Ajustar el espacio entre los subgráficos
plt.subplots_adjust(hspace=0.3, wspace=0.3)

# Definir los valores únicos de 'Vict Descent' para iterar sobre ellos
vict_descents = df_filtered['Vict Descent'].unique()

# Crear un gráfico de barras apiladas para cada 'Vict Descent'
for i, descent in enumerate(vict_descents):
    # Obtener el eje correspondiente (usamos el índice 'i' para acceder a los subgráficos)
    ax = axes[i // 2, i % 2]

    # Filtrar el DataFrame para este 'Vict Descent'
    df_descent = df_filtered[df_filtered['Vict Descent'] == descent]

    # Agrupar por mes y sexo de la víctima y contar los crímenes
    crime_counts = df_descent.groupby(['month', 'Vict Sex']).size().unstack(fill_value=0)

    # Crear las barras apiladas
    crime_counts.plot(kind='bar', stacked=True, ax=ax, color=['#FF6347', '#4682B4', '#32CD32'], alpha=0.7)

    # Configurar el título y las etiquetas del gráfico
    ax.set_title(f'Vict Descent: {descent}')
    ax.set_xlabel('Mes')
    ax.set_ylabel('Número de Crímenes')
    ax.set_xticklabels(crime_counts.index, rotation=45)

    # Eliminar la leyenda dentro de cada gráfico
    ax.get_legend().remove()

# Crear una leyenda global en la parte superior central
handles, labels = axes[0, 0].get_legend_handles_labels()
fig.legend(
    handles,
    labels,
    loc='upper center',
    bbox_to_anchor=(0.5, 1),
    ncol=3,
    title="Vict Sex",
)

# Mostrar el gráfico
plt.show()

import matplotlib.pyplot as plt

# Filtrar el DataFrame para solo incluir los valores deseados de 'Vict Sex'
df_filtered = df[df['Vict Sex'].isin(['M', 'F', 'X'])]

# Contar los crímenes totales por 'Vict Sex'
crime_counts = df_filtered['Vict Sex'].value_counts()

# Definir los colores con transparencia (añadiendo un canal alfa)
colors = ['#FF634780', '#4682B480', '#32CD3280']  # Transparencia con alfa (80)

# Crear el gráfico de sectores
plt.figure(figsize=(8, 8))
wedges, texts, autotexts = plt.pie(
    crime_counts,
    labels=crime_counts.index,
    autopct='%1.1f%%',
    startangle=140,
    colors=colors,
    textprops={'fontsize': 12, 'weight': 'bold', 'color': 'darkred'},
    wedgeprops={'edgecolor': 'white', 'linewidth': 1.5},
)

# Personalizar etiquetas de los porcentajes
for autotext in autotexts:
    autotext.set_color('darkblue')
    autotext.set_fontsize(12)
    autotext.set_weight('bold')

# Añadir un borde blanco a las etiquetas de texto para mejorar legibilidad
for text in texts:
    text.set_bbox(dict(facecolor='white', edgecolor='none', alpha=0.7))

# Añadir título al gráfico con estilo
plt.title(
    'Distribución de Crímenes por Sexo de la Víctima',
    fontsize=16,
    weight='bold',
    color='black',
    pad=20,
)

# Mostrar el gráfico
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Asegurarse de que 'day' está en formato numérico
df['day'] = pd.to_numeric(df['day'], errors='coerce')

# Calcular el promedio de crímenes por día del mes para cada 'Status Desc'
avg_crimes_per_day = (
    df.groupby(['day', 'Status Desc'])
    .size()
    .reset_index(name='Average Crimes')
)

# Configurar el tamaño del gráfico y el estilo
plt.figure(figsize=(16, 8))
sns.set(style="whitegrid")

# Crear el gráfico de líneas
line_plot = sns.lineplot(
    data=avg_crimes_per_day,
    x='day',
    y='Average Crimes',
    hue='Status Desc',
    palette='Set2',  # Colores distintivos
    linewidth=2
)

# Ajustar título y etiquetas
plt.title('Promedio de Crímenes por Día del Mes (Agrupado por Estado)', fontsize=16, weight='bold')
plt.xlabel('Día del Mes', fontsize=12)
plt.ylabel('Promedio de Crímenes', fontsize=12)

# Ajustar las etiquetas del eje x
plt.xticks(range(1, 32))  # Días típicos del mes (1 al 31)

# Mejorar la leyenda
plt.legend(
    title='Status Desc',
    loc='upper right',
    fontsize=10,
    title_fontsize=12,
    frameon=True,
    framealpha=0.8,
    borderpad=1
)

# Ajustar el diseño y mostrar el gráfico
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Filtrar solo los datos donde 'Status Desc' es "Adult Arrest"
df_filtered = df[df['Status Desc'] == "Adult Arrest"]

# Asegurarnos de que 'TIME OCC' sea un string para manejar correctamente los valores
df_filtered['TIME OCC'] = df_filtered['TIME OCC'].astype(str).str.zfill(4)  # Asegura que tenga 4 dígitos

# Función para convertir TIME OCC (HHMM) a hora decimal
def convertir_a_hora(x):
    try:
        # Asegurarse de que se tiene un valor válido con al menos 4 caracteres
        if len(x) == 4:
            horas = int(x[:2])
            minutos = int(x[2:])
            return horas + minutos / 60
        else:
            return None  # Si el formato no es válido, retornamos None
    except ValueError:
        return None  # En caso de que haya un error al convertir, retornamos None

# Aplicar la conversión de hora
df_filtered['Hora'] = df_filtered['TIME OCC'].apply(convertir_a_hora)

# Eliminar filas con valores nulos (None) en la columna 'Hora'
df_filtered = df_filtered.dropna(subset=['Hora'])

# Crear el subplot 2x2
fig, axes = plt.subplots(2, 2, figsize=[12, 12])  # Tamaño del gráfico

# Lista de categorías para 'Vict Descent'
categories = ['W', 'B', 'H', 'A']
axes = axes.flatten()  # Convertir la matriz de ejes a un arreglo unidimensional

# Crear un gráfico para cada categoría de 'Vict Descent'
for i, descent in enumerate(categories):
    # Filtrar los datos para la categoría actual
    df_subset = df_filtered[df_filtered['Vict Descent'] == descent]

    # Graficar en el subplot correspondiente
    sns.scatterplot(data=df_subset, x='Hora', y='Vict Age', s=10, ax=axes[i])
    sns.rugplot(data=df_subset, x='Hora', y='Vict Age', lw=1, alpha=0.005, ax=axes[i])

    # Personalizar el gráfico
    axes[i].set_title(f'Scatterplot - Vict Descent: {descent}')
    axes[i].set_xlabel('Hora de la ocurrencia')
    axes[i].set_ylabel('Edad de la víctima')

# Ajustar el espacio entre los subgráficos
plt.tight_layout()

# Mostrar el gráfico
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Filtrar solo los datos donde 'Status Desc' es "Adult Arrest"
df_filtered = df[df['Status Desc'] == "Adult Arrest"]

# Asegurarnos de que 'TIME OCC' sea un string para manejar correctamente los valores
df_filtered['TIME OCC'] = df_filtered['TIME OCC'].astype(str).str.zfill(4)  # Asegura que tenga 4 dígitos

# Función para convertir TIME OCC (HHMM) a hora decimal
def convertir_a_hora(x):
    try:
        # Asegurarse de que se tiene un valor válido con al menos 4 caracteres
        if len(x) == 4:
            horas = int(x[:2])
            minutos = int(x[2:])
            return horas + minutos / 60
        else:
            return None  # Si el formato no es válido, retornamos None
    except ValueError:
        return None  # En caso de que haya un error al convertir, retornamos None

# Aplicar la conversión de hora
df_filtered['Hora'] = df_filtered['TIME OCC'].apply(convertir_a_hora)

# Eliminar filas con valores nulos (None) en la columna 'Hora'
df_filtered = df_filtered.dropna(subset=['Hora'])

# Crear el subplot 2x2
fig, axes = plt.subplots(2, 2, figsize=[12, 12])  # Tamaño del gráfico

# Lista de categorías para 'Vict Descent'
categories = ['W', 'B', 'H', 'A']
axes = axes.flatten()  # Convertir la matriz de ejes a un arreglo unidimensional

# Crear un histograma para cada categoría de 'Vict Descent'
for i, descent in enumerate(categories):
    # Filtrar los datos para la categoría actual
    df_subset = df_filtered[df_filtered['Vict Descent'] == descent]

    # Graficar el histograma en el subplot correspondiente
    sns.histplot(df_subset['Vict Age'], kde=True, bins=20, ax=axes[i], color='blue')

    # Personalizar el gráfico
    axes[i].set_title(f'Histograma - Vict Descent: {descent}')
    axes[i].set_xlabel('Edad de la víctima')
    axes[i].set_ylabel('Frecuencia')

# Ajustar el espacio entre los subgráficos
plt.tight_layout()

# Mostrar el gráfico
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Filtrar solo los datos donde 'Status Desc' es "Adult Arrest"
df_filtered = df[df['Status Desc'] == "Adult Arrest"]

# Asegurarnos de que 'TIME OCC' sea un string para manejar correctamente los valores
df_filtered['TIME OCC'] = df_filtered['TIME OCC'].astype(str).str.zfill(4)  # Asegura que tenga 4 dígitos

# Función para convertir TIME OCC (HHMM) a hora decimal
def convertir_a_hora(x):
    try:
        # Asegurarse de que se tiene un valor válido con al menos 4 caracteres
        if len(x) == 4:
            horas = int(x[:2])
            minutos = int(x[2:])
            return horas + minutos / 60
        else:
            return None  # Si el formato no es válido, retornamos None
    except ValueError:
        return None  # En caso de que haya un error al convertir, retornamos None

# Aplicar la conversión de hora
df_filtered['Hora'] = df_filtered['TIME OCC'].apply(convertir_a_hora)

# Eliminar filas con valores nulos (None) en la columna 'Hora'
df_filtered = df_filtered.dropna(subset=['Hora'])

# Crear el subplot 2x2
fig, axes = plt.subplots(2, 2, figsize=[12, 12])  # Tamaño del gráfico

# Lista de categorías para 'Vict Descent'
categories = ['W', 'B', 'H', 'A']
axes = axes.flatten()  # Convertir la matriz de ejes a un arreglo unidimensional

# Crear un histograma para cada categoría de 'Vict Descent'
for i, descent in enumerate(categories):
    # Filtrar los datos para la categoría actual
    df_subset = df_filtered[df_filtered['Vict Descent'] == descent]

    # Graficar el histograma en el subplot correspondiente
    sns.histplot(df_subset['Hora'], kde=False, bins=24, ax=axes[i], color='blue')

    # Personalizar el gráfico
    axes[i].set_title(f'Histograma - Vict Descent: {descent}')
    axes[i].set_xlabel('Hora de la ocurrencia')
    axes[i].set_ylabel('Frecuencia')

# Ajustar el espacio entre los subgráficos
plt.tight_layout()

# Mostrar el gráfico
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Filtrar solo los datos donde 'Status Desc' es "Adult Arrest"
df_filtered = df[df['Status Desc'] == "Adult Arrest"]

# Filtrar para que solo aparezcan los valores de 'Vict Sex' M, F, X
df_filtered = df_filtered[df_filtered['Vict Sex'].isin(['M', 'F'])]

# Asegurarnos de que 'TIME OCC' sea un string para manejar correctamente los valores
df_filtered['TIME OCC'] = df_filtered['TIME OCC'].astype(str).str.zfill(4)  # Asegura que tenga 4 dígitos

# Función para convertir TIME OCC (HHMM) a hora decimal
def convertir_a_hora(x):
    try:
        # Asegurarse de que se tiene un valor válido con al menos 4 caracteres
        if len(x) == 4:
            horas = int(x[:2])
            minutos = int(x[2:])
            return horas + minutos / 60
        else:
            return None  # Si el formato no es válido, retornamos None
    except ValueError:
        return None  # En caso de que haya un error al convertir, retornamos None

# Aplicar la conversión de hora
df_filtered['Hora'] = df_filtered['TIME OCC'].apply(convertir_a_hora)

# Eliminar filas con valores nulos (None) en la columna 'Hora'
df_filtered = df_filtered.dropna(subset=['Hora'])

# Crear el subplot 2x2
fig, axes = plt.subplots(2, 2, figsize=[12, 12])  # Tamaño del gráfico

# Lista de categorías para 'Vict Descent' incluyendo 'H'
categories = ['W', 'B', 'A', 'H']  # Incluir 'H' ahora
axes = axes.flatten()  # Convertir la matriz de ejes a un arreglo unidimensional

# Colores para la leyenda
palette = sns.color_palette("Set2", n_colors=2)  # Colores para M, F

# Crear un histograma para cada categoría de 'Vict Descent'
for i, descent in enumerate(categories):
    # Filtrar los datos para la categoría actual
    df_subset = df_filtered[df_filtered['Vict Descent'] == descent]

    # Graficar el histograma apilado con las líneas de tendencia (KDE)
    sns.histplot(df_subset, x='Hora', hue='Vict Sex', kde=True, bins=24, ax=axes[i],
                 multiple='stack', palette=palette, element='step', stat='count', legend=False)

    # Personalizar el gráfico
    axes[i].set_title(f'Histograma apilado - Vict Descent: {descent}')
    axes[i].set_xlabel('Hora de la ocurrencia')
    axes[i].set_ylabel('Frecuencia')

# Ajustar el espacio entre los subgráficos
plt.tight_layout()

# Crear la leyenda manualmente
handles, labels = [], []
for sex, color in zip(['M', 'F', 'X'], palette):
    handles.append(plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10))
    labels.append(sex)

# Mostrar la leyenda una sola vez (fuera de los subgráficos)
fig.legend(handles, labels, loc='upper left', bbox_to_anchor=(1, 1), title='Vict Sex', ncol=1, fontsize=10)  # Ajustar la leyenda

# Mostrar el gráfico
plt.show()